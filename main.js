/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// node_modules/pluralize/pluralize.js
var require_pluralize = __commonJS({
  "node_modules/pluralize/pluralize.js"(exports, module2) {
    (function(root, pluralize) {
      if (typeof require === "function" && typeof exports === "object" && typeof module2 === "object") {
        module2.exports = pluralize();
      } else if (typeof define === "function" && define.amd) {
        define(function() {
          return pluralize();
        });
      } else {
        root.pluralize = pluralize();
      }
    })(exports, function() {
      var pluralRules = [];
      var singularRules = [];
      var uncountables = {};
      var irregularPlurals = {};
      var irregularSingles = {};
      function sanitizeRule(rule) {
        if (typeof rule === "string") {
          return new RegExp("^" + rule + "$", "i");
        }
        return rule;
      }
      function restoreCase(word, token) {
        if (word === token)
          return token;
        if (word === word.toUpperCase())
          return token.toUpperCase();
        if (word[0] === word[0].toUpperCase()) {
          return token.charAt(0).toUpperCase() + token.substr(1).toLowerCase();
        }
        return token.toLowerCase();
      }
      function interpolate(str, args) {
        return str.replace(/\$(\d{1,2})/g, function(match, index) {
          return args[index] || "";
        });
      }
      function replace(word, rule) {
        return word.replace(rule[0], function(match, index) {
          var result = interpolate(rule[1], arguments);
          if (match === "") {
            return restoreCase(word[index - 1], result);
          }
          return restoreCase(match, result);
        });
      }
      function sanitizeWord(token, word, rules) {
        if (!token.length || uncountables.hasOwnProperty(token)) {
          return word;
        }
        var len = rules.length;
        while (len--) {
          var rule = rules[len];
          if (rule[0].test(word))
            return replace(word, rule);
        }
        return word;
      }
      function replaceWord(replaceMap, keepMap, rules) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token)) {
            return restoreCase(word, token);
          }
          if (replaceMap.hasOwnProperty(token)) {
            return restoreCase(word, replaceMap[token]);
          }
          return sanitizeWord(token, word, rules);
        };
      }
      function checkWord(replaceMap, keepMap, rules, bool) {
        return function(word) {
          var token = word.toLowerCase();
          if (keepMap.hasOwnProperty(token))
            return true;
          if (replaceMap.hasOwnProperty(token))
            return false;
          return sanitizeWord(token, token, rules) === token;
        };
      }
      function pluralize(word, count, inclusive) {
        var pluralized = count === 1 ? pluralize.singular(word) : pluralize.plural(word);
        return (inclusive ? count + " " : "") + pluralized;
      }
      pluralize.plural = replaceWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize.isPlural = checkWord(
        irregularSingles,
        irregularPlurals,
        pluralRules
      );
      pluralize.singular = replaceWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize.isSingular = checkWord(
        irregularPlurals,
        irregularSingles,
        singularRules
      );
      pluralize.addPluralRule = function(rule, replacement) {
        pluralRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addSingularRule = function(rule, replacement) {
        singularRules.push([sanitizeRule(rule), replacement]);
      };
      pluralize.addUncountableRule = function(word) {
        if (typeof word === "string") {
          uncountables[word.toLowerCase()] = true;
          return;
        }
        pluralize.addPluralRule(word, "$0");
        pluralize.addSingularRule(word, "$0");
      };
      pluralize.addIrregularRule = function(single, plural) {
        plural = plural.toLowerCase();
        single = single.toLowerCase();
        irregularSingles[single] = plural;
        irregularPlurals[plural] = single;
      };
      [
        // Pronouns.
        ["I", "we"],
        ["me", "us"],
        ["he", "they"],
        ["she", "they"],
        ["them", "them"],
        ["myself", "ourselves"],
        ["yourself", "yourselves"],
        ["itself", "themselves"],
        ["herself", "themselves"],
        ["himself", "themselves"],
        ["themself", "themselves"],
        ["is", "are"],
        ["was", "were"],
        ["has", "have"],
        ["this", "these"],
        ["that", "those"],
        // Words ending in with a consonant and `o`.
        ["echo", "echoes"],
        ["dingo", "dingoes"],
        ["volcano", "volcanoes"],
        ["tornado", "tornadoes"],
        ["torpedo", "torpedoes"],
        // Ends with `us`.
        ["genus", "genera"],
        ["viscus", "viscera"],
        // Ends with `ma`.
        ["stigma", "stigmata"],
        ["stoma", "stomata"],
        ["dogma", "dogmata"],
        ["lemma", "lemmata"],
        ["schema", "schemata"],
        ["anathema", "anathemata"],
        // Other irregular rules.
        ["ox", "oxen"],
        ["axe", "axes"],
        ["die", "dice"],
        ["yes", "yeses"],
        ["foot", "feet"],
        ["eave", "eaves"],
        ["goose", "geese"],
        ["tooth", "teeth"],
        ["quiz", "quizzes"],
        ["human", "humans"],
        ["proof", "proofs"],
        ["carve", "carves"],
        ["valve", "valves"],
        ["looey", "looies"],
        ["thief", "thieves"],
        ["groove", "grooves"],
        ["pickaxe", "pickaxes"],
        ["whiskey", "whiskies"]
      ].forEach(function(rule) {
        return pluralize.addIrregularRule(rule[0], rule[1]);
      });
      [
        [/s?$/i, "s"],
        [/[^\u0000-\u007F]$/i, "$0"],
        [/([^aeiou]ese)$/i, "$1"],
        [/(ax|test)is$/i, "$1es"],
        [/(alias|[^aou]us|tlas|gas|ris)$/i, "$1es"],
        [/(e[mn]u)s?$/i, "$1s"],
        [/([^l]ias|[aeiou]las|[emjzr]as|[iu]am)$/i, "$1"],
        [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1i"],
        [/(alumn|alg|vertebr)(?:a|ae)$/i, "$1ae"],
        [/(seraph|cherub)(?:im)?$/i, "$1im"],
        [/(her|at|gr)o$/i, "$1oes"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|automat|quor)(?:a|um)$/i, "$1a"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)(?:a|on)$/i, "$1a"],
        [/sis$/i, "ses"],
        [/(?:(kni|wi|li)fe|(ar|l|ea|eo|oa|hoo)f)$/i, "$1$2ves"],
        [/([^aeiouy]|qu)y$/i, "$1ies"],
        [/([^ch][ieo][ln])ey$/i, "$1ies"],
        [/(x|ch|ss|sh|zz)$/i, "$1es"],
        [/(matr|cod|mur|sil|vert|ind|append)(?:ix|ex)$/i, "$1ices"],
        [/(m|l)(?:ice|ouse)$/i, "$1ice"],
        [/(pe)(?:rson|ople)$/i, "$1ople"],
        [/(child)(?:ren)?$/i, "$1ren"],
        [/eaux$/i, "$0"],
        [/m[ae]n$/i, "men"],
        ["thou", "you"]
      ].forEach(function(rule) {
        return pluralize.addPluralRule(rule[0], rule[1]);
      });
      [
        [/s$/i, ""],
        [/(ss)$/i, "$1"],
        [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)(?:sis|ses)$/i, "$1sis"],
        [/(^analy)(?:sis|ses)$/i, "$1sis"],
        [/(wi|kni|(?:after|half|high|low|mid|non|night|[^\w]|^)li)ves$/i, "$1fe"],
        [/(ar|(?:wo|[ae])l|[eo][ao])ves$/i, "$1f"],
        [/ies$/i, "y"],
        [/\b([pl]|zomb|(?:neck|cross)?t|coll|faer|food|gen|goon|group|lass|talk|goal|cut)ies$/i, "$1ie"],
        [/\b(mon|smil)ies$/i, "$1ey"],
        [/(m|l)ice$/i, "$1ouse"],
        [/(seraph|cherub)im$/i, "$1"],
        [/(x|ch|ss|sh|zz|tto|go|cho|alias|[^aou]us|tlas|gas|(?:her|at|gr)o|ris)(?:es)?$/i, "$1"],
        [/(e[mn]u)s?$/i, "$1"],
        [/(movie|twelve)s$/i, "$1"],
        [/(cris|test|diagnos)(?:is|es)$/i, "$1is"],
        [/(alumn|syllab|octop|vir|radi|nucle|fung|cact|stimul|termin|bacill|foc|uter|loc|strat)(?:us|i)$/i, "$1us"],
        [/(agend|addend|millenni|dat|extrem|bacteri|desiderat|strat|candelabr|errat|ov|symposi|curricul|quor)a$/i, "$1um"],
        [/(apheli|hyperbat|periheli|asyndet|noumen|phenomen|criteri|organ|prolegomen|hedr|automat)a$/i, "$1on"],
        [/(alumn|alg|vertebr)ae$/i, "$1a"],
        [/(cod|mur|sil|vert|ind)ices$/i, "$1ex"],
        [/(matr|append)ices$/i, "$1ix"],
        [/(pe)(rson|ople)$/i, "$1rson"],
        [/(child)ren$/i, "$1"],
        [/(eau)x?$/i, "$1"],
        [/men$/i, "man"]
      ].forEach(function(rule) {
        return pluralize.addSingularRule(rule[0], rule[1]);
      });
      [
        // Singular words with no plurals.
        "adulthood",
        "advice",
        "agenda",
        "aid",
        "alcohol",
        "ammo",
        "anime",
        "athletics",
        "audio",
        "bison",
        "blood",
        "bream",
        "buffalo",
        "butter",
        "carp",
        "cash",
        "chassis",
        "chess",
        "clothing",
        "cod",
        "commerce",
        "cooperation",
        "corps",
        "debris",
        "diabetes",
        "digestion",
        "elk",
        "energy",
        "equipment",
        "excretion",
        "expertise",
        "flounder",
        "fun",
        "gallows",
        "garbage",
        "graffiti",
        "headquarters",
        "health",
        "herpes",
        "highjinks",
        "homework",
        "housework",
        "information",
        "jeans",
        "justice",
        "kudos",
        "labour",
        "literature",
        "machinery",
        "mackerel",
        "mail",
        "media",
        "mews",
        "moose",
        "music",
        "manga",
        "news",
        "pike",
        "plankton",
        "pliers",
        "pollution",
        "premises",
        "rain",
        "research",
        "rice",
        "salmon",
        "scissors",
        "series",
        "sewage",
        "shambles",
        "shrimp",
        "species",
        "staff",
        "swine",
        "tennis",
        "traffic",
        "transporation",
        "trout",
        "tuna",
        "wealth",
        "welfare",
        "whiting",
        "wildebeest",
        "wildlife",
        "you",
        // Regexes.
        /[^aeiou]ese$/i,
        // "chinese", "japanese"
        /deer$/i,
        // "deer", "reindeer"
        /fish$/i,
        // "fish", "blowfish", "angelfish"
        /measles$/i,
        /o[iu]s$/i,
        // "carnivorous"
        /pox$/i,
        // "chickpox", "smallpox"
        /sheep$/i
      ].forEach(pluralize.addUncountableRule);
      return pluralize;
    });
  }
});

// node_modules/normalize-strings/charmap.json
var require_charmap = __commonJS({
  "node_modules/normalize-strings/charmap.json"(exports, module2) {
    module2.exports = { "105": "i", "192": "A", "193": "A", "194": "A", "195": "A", "196": "A", "197": "A", "199": "C", "200": "E", "201": "E", "202": "E", "203": "E", "204": "I", "205": "I", "206": "I", "207": "I", "209": "N", "210": "O", "211": "O", "212": "O", "213": "O", "214": "O", "216": "O", "217": "U", "218": "U", "219": "U", "220": "U", "221": "Y", "224": "a", "225": "a", "226": "a", "227": "a", "228": "a", "229": "a", "231": "c", "232": "e", "233": "e", "234": "e", "235": "e", "236": "i", "237": "i", "238": "i", "239": "i", "241": "n", "242": "o", "243": "o", "244": "o", "245": "o", "246": "o", "248": "o", "249": "u", "250": "u", "251": "u", "252": "u", "253": "y", "255": "y", "256": "A", "257": "a", "258": "A", "259": "a", "260": "A", "261": "a", "262": "C", "263": "c", "264": "C", "265": "c", "266": "C", "267": "c", "268": "C", "269": "c", "270": "D", "271": "d", "272": "D", "273": "d", "274": "E", "275": "e", "276": "E", "277": "e", "278": "E", "279": "e", "280": "E", "281": "e", "282": "E", "283": "e", "284": "G", "285": "g", "286": "G", "287": "g", "288": "G", "289": "g", "290": "G", "291": "g", "292": "H", "293": "h", "294": "H", "295": "h", "296": "I", "297": "i", "298": "I", "299": "i", "300": "I", "301": "i", "302": "I", "303": "i", "304": "I", "308": "J", "309": "j", "310": "K", "311": "k", "313": "L", "314": "l", "315": "L", "316": "l", "317": "L", "318": "l", "319": "L", "320": "l", "321": "L", "322": "l", "323": "N", "324": "n", "325": "N", "326": "n", "327": "N", "328": "n", "332": "O", "333": "o", "334": "O", "335": "o", "336": "O", "337": "o", "338": "O", "339": "o", "340": "R", "341": "r", "342": "R", "343": "r", "344": "R", "345": "r", "346": "S", "347": "s", "348": "S", "349": "s", "350": "S", "351": "s", "352": "S", "353": "s", "354": "T", "355": "t", "356": "T", "357": "t", "358": "T", "359": "t", "360": "U", "361": "u", "362": "U", "363": "u", "364": "U", "365": "u", "366": "U", "367": "u", "368": "U", "369": "u", "370": "U", "371": "u", "372": "W", "373": "w", "374": "Y", "375": "y", "376": "Y", "377": "Z", "378": "z", "379": "Z", "380": "z", "381": "Z", "382": "z", "384": "b", "385": "B", "386": "B", "387": "b", "390": "O", "391": "C", "392": "c", "393": "D", "394": "D", "395": "D", "396": "d", "398": "E", "400": "E", "401": "F", "402": "f", "403": "G", "407": "I", "408": "K", "409": "k", "410": "l", "412": "M", "413": "N", "414": "n", "415": "O", "416": "O", "417": "o", "420": "P", "421": "p", "422": "R", "427": "t", "428": "T", "429": "t", "430": "T", "431": "U", "432": "u", "434": "V", "435": "Y", "436": "y", "437": "Z", "438": "z", "461": "A", "462": "a", "463": "I", "464": "i", "465": "O", "466": "o", "467": "U", "468": "u", "477": "e", "484": "G", "485": "g", "486": "G", "487": "g", "488": "K", "489": "k", "490": "O", "491": "o", "500": "G", "501": "g", "504": "N", "505": "n", "512": "A", "513": "a", "514": "A", "515": "a", "516": "E", "517": "e", "518": "E", "519": "e", "520": "I", "521": "i", "522": "I", "523": "i", "524": "O", "525": "o", "526": "O", "527": "o", "528": "R", "529": "r", "530": "R", "531": "r", "532": "U", "533": "u", "534": "U", "535": "u", "536": "S", "537": "s", "538": "T", "539": "t", "542": "H", "543": "h", "544": "N", "545": "d", "548": "Z", "549": "z", "550": "A", "551": "a", "552": "E", "553": "e", "558": "O", "559": "o", "562": "Y", "563": "y", "564": "l", "565": "n", "566": "t", "567": "j", "570": "A", "571": "C", "572": "c", "573": "L", "574": "T", "575": "s", "576": "z", "579": "B", "580": "U", "581": "V", "582": "E", "583": "e", "584": "J", "585": "j", "586": "Q", "587": "q", "588": "R", "589": "r", "590": "Y", "591": "y", "592": "a", "593": "a", "595": "b", "596": "o", "597": "c", "598": "d", "599": "d", "600": "e", "603": "e", "604": "e", "605": "e", "606": "e", "607": "j", "608": "g", "609": "g", "610": "g", "613": "h", "614": "h", "616": "i", "618": "i", "619": "l", "620": "l", "621": "l", "623": "m", "624": "m", "625": "m", "626": "n", "627": "n", "628": "n", "629": "o", "633": "r", "634": "r", "635": "r", "636": "r", "637": "r", "638": "r", "639": "r", "640": "r", "641": "r", "642": "s", "647": "t", "648": "t", "649": "u", "651": "v", "652": "v", "653": "w", "654": "y", "655": "y", "656": "z", "657": "z", "663": "c", "665": "b", "666": "e", "667": "g", "668": "h", "669": "j", "670": "k", "671": "l", "672": "q", "686": "h", "688": "h", "690": "j", "691": "r", "692": "r", "694": "r", "695": "w", "696": "y", "737": "l", "738": "s", "739": "x", "780": "v", "829": "x", "851": "x", "867": "a", "868": "e", "869": "i", "870": "o", "871": "u", "872": "c", "873": "d", "874": "h", "875": "m", "876": "r", "877": "t", "878": "v", "879": "x", "7424": "a", "7427": "b", "7428": "c", "7429": "d", "7431": "e", "7432": "e", "7433": "i", "7434": "j", "7435": "k", "7436": "l", "7437": "m", "7438": "n", "7439": "o", "7440": "o", "7441": "o", "7442": "o", "7443": "o", "7446": "o", "7447": "o", "7448": "p", "7449": "r", "7450": "r", "7451": "t", "7452": "u", "7453": "u", "7454": "u", "7455": "m", "7456": "v", "7457": "w", "7458": "z", "7522": "i", "7523": "r", "7524": "u", "7525": "v", "7680": "A", "7681": "a", "7682": "B", "7683": "b", "7684": "B", "7685": "b", "7686": "B", "7687": "b", "7690": "D", "7691": "d", "7692": "D", "7693": "d", "7694": "D", "7695": "d", "7696": "D", "7697": "d", "7698": "D", "7699": "d", "7704": "E", "7705": "e", "7706": "E", "7707": "e", "7710": "F", "7711": "f", "7712": "G", "7713": "g", "7714": "H", "7715": "h", "7716": "H", "7717": "h", "7718": "H", "7719": "h", "7720": "H", "7721": "h", "7722": "H", "7723": "h", "7724": "I", "7725": "i", "7728": "K", "7729": "k", "7730": "K", "7731": "k", "7732": "K", "7733": "k", "7734": "L", "7735": "l", "7738": "L", "7739": "l", "7740": "L", "7741": "l", "7742": "M", "7743": "m", "7744": "M", "7745": "m", "7746": "M", "7747": "m", "7748": "N", "7749": "n", "7750": "N", "7751": "n", "7752": "N", "7753": "n", "7754": "N", "7755": "n", "7764": "P", "7765": "p", "7766": "P", "7767": "p", "7768": "R", "7769": "r", "7770": "R", "7771": "r", "7774": "R", "7775": "r", "7776": "S", "7777": "s", "7778": "S", "7779": "s", "7786": "T", "7787": "t", "7788": "T", "7789": "t", "7790": "T", "7791": "t", "7792": "T", "7793": "t", "7794": "U", "7795": "u", "7796": "U", "7797": "u", "7798": "U", "7799": "u", "7804": "V", "7805": "v", "7806": "V", "7807": "v", "7808": "W", "7809": "w", "7810": "W", "7811": "w", "7812": "W", "7813": "w", "7814": "W", "7815": "w", "7816": "W", "7817": "w", "7818": "X", "7819": "x", "7820": "X", "7821": "x", "7822": "Y", "7823": "y", "7824": "Z", "7825": "z", "7826": "Z", "7827": "z", "7828": "Z", "7829": "z", "7835": "s", "7840": "A", "7841": "a", "7842": "A", "7843": "a", "7864": "E", "7865": "e", "7866": "E", "7867": "e", "7868": "E", "7869": "e", "7880": "I", "7881": "i", "7882": "I", "7883": "i", "7884": "O", "7885": "o", "7886": "O", "7887": "o", "7908": "U", "7909": "u", "7910": "U", "7911": "u", "7922": "Y", "7923": "y", "7924": "Y", "7925": "y", "7926": "Y", "7927": "y", "7928": "Y", "7929": "y", "8305": "i", "8341": "h", "8342": "k", "8343": "l", "8344": "m", "8345": "n", "8346": "p", "8347": "s", "8348": "t", "8450": "c", "8458": "g", "8459": "h", "8460": "h", "8461": "h", "8464": "i", "8465": "i", "8466": "l", "8467": "l", "8468": "l", "8469": "n", "8472": "p", "8473": "p", "8474": "q", "8475": "r", "8476": "r", "8477": "r", "8484": "z", "8488": "z", "8492": "b", "8493": "c", "8495": "e", "8496": "e", "8497": "f", "8498": "F", "8499": "m", "8500": "o", "8506": "q", "8513": "g", "8514": "l", "8515": "l", "8516": "y", "8517": "d", "8518": "d", "8519": "e", "8520": "i", "8521": "j", "8526": "f", "8579": "C", "8580": "c", "8765": "s", "8766": "s", "8959": "z", "8999": "x", "9746": "x", "9776": "i", "9866": "i", "10005": "x", "10006": "x", "10007": "x", "10008": "x", "10625": "z", "10626": "z", "11362": "L", "11364": "R", "11365": "a", "11366": "t", "11373": "A", "11374": "M", "11375": "A", "11390": "S", "11391": "Z", "19904": "i", "42893": "H", "42922": "H", "42923": "E", "42924": "G", "42925": "L", "42928": "K", "42929": "T", "62937": "x" };
  }
});

// node_modules/normalize-strings/index.js
var require_normalize_strings = __commonJS({
  "node_modules/normalize-strings/index.js"(exports, module2) {
    (function(global, factory) {
      if (typeof define === "function" && define.amd) {
        define(function() {
          return factory(global, global.document);
        });
      } else if (typeof module2 !== "undefined" && module2.exports) {
        module2.exports = factory(global, global.document);
      } else {
        global.normalize = factory(global, global.document);
      }
    })(typeof window !== "undefined" ? window : exports, function(window2, document) {
      var charmap = require_charmap();
      var regex = null;
      var current_charmap;
      var old_charmap;
      function normalize(str, custom_charmap) {
        old_charmap = current_charmap;
        current_charmap = custom_charmap || charmap;
        regex = regex && old_charmap === current_charmap ? regex : buildRegExp(current_charmap);
        return str.replace(regex, function(charToReplace) {
          return current_charmap[charToReplace.charCodeAt(0)] || charToReplace;
        });
      }
      function buildRegExp(charmap2) {
        return new RegExp("[" + Object.keys(charmap2).map(function(code) {
          return String.fromCharCode(code);
        }).join(" ") + "]", "g");
      }
      return normalize;
    });
  }
});

// node_modules/syllable/problematic.json
var require_problematic = __commonJS({
  "node_modules/syllable/problematic.json"(exports, module2) {
    module2.exports = {
      abalone: 4,
      abare: 3,
      abed: 2,
      abruzzese: 4,
      abbruzzese: 4,
      aborigine: 5,
      acreage: 3,
      adame: 3,
      adieu: 2,
      adobe: 3,
      anemone: 4,
      apache: 3,
      aphrodite: 4,
      apostrophe: 4,
      ariadne: 4,
      cafe: 2,
      calliope: 4,
      catastrophe: 4,
      chile: 2,
      chloe: 2,
      circe: 2,
      coyote: 3,
      epitome: 4,
      forever: 3,
      gethsemane: 4,
      guacamole: 4,
      hyperbole: 4,
      jesse: 2,
      jukebox: 2,
      karate: 3,
      machete: 3,
      maybe: 2,
      people: 2,
      recipe: 3,
      sesame: 3,
      shoreline: 2,
      simile: 3,
      syncope: 3,
      tamale: 3,
      yosemite: 4,
      daphne: 2,
      eurydice: 4,
      euterpe: 3,
      hermione: 4,
      penelope: 4,
      persephone: 4,
      phoebe: 2,
      zoe: 2
    };
  }
});

// node_modules/syllable/index.js
var require_syllable = __commonJS({
  "node_modules/syllable/index.js"(exports, module2) {
    "use strict";
    var pluralize = require_pluralize();
    var normalize = require_normalize_strings();
    var problematic = require_problematic();
    module2.exports = syllables;
    var own = {}.hasOwnProperty;
    var EXPRESSION_MONOSYLLABIC_ONE = new RegExp(
      "cia(l|$)|tia|cius|cious|[^aeiou]giu|[aeiouy][^aeiouy]ion|iou|sia$|eous$|[oa]gue$|.[^aeiuoycgltdb]{2,}ed$|.ely$|^jua|uai|eau|^busi$|([aeiouy](b|c|ch|dg|f|g|gh|gn|k|l|lch|ll|lv|m|mm|n|nc|ng|nch|nn|p|r|rc|rn|rs|rv|s|sc|sk|sl|squ|ss|th|v|y|z)ed$)|([aeiouy](b|ch|d|f|gh|gn|k|l|lch|ll|lv|m|mm|n|nch|nn|p|r|rn|rs|rv|s|sc|sk|sl|squ|ss|st|t|th|v|y)es$)",
      "g"
    );
    var EXPRESSION_MONOSYLLABIC_TWO = new RegExp(
      "[aeiouy](b|c|ch|d|dg|f|g|gh|gn|k|l|ll|lv|m|mm|n|nc|ng|nn|p|r|rc|rn|rs|rv|s|sc|sk|sl|squ|ss|st|t|th|v|y|z)e$",
      "g"
    );
    var EXPRESSION_DOUBLE_SYLLABIC_ONE = new RegExp(
      "(([^aeiouy])\\2l|[^aeiouy]ie(r|st|t)|[aeiouym]bl|eo|ism|asm|thm|dnt|uity|dea|gean|oa|ua|eings?|[aeiouy]sh?e[rsd])$",
      "g"
    );
    var EXPRESSION_DOUBLE_SYLLABIC_TWO = new RegExp(
      "[^gq]ua[^auieo]|[aeiou]{3}|^(ia|mc|coa[dglx].)",
      "g"
    );
    var EXPRESSION_DOUBLE_SYLLABIC_THREE = new RegExp(
      "[^aeiou]y[ae]|[^l]lien|riet|dien|iu|io|ii|uen|real|iell|eo[^aeiou]|[aeiou]y[aeiou]",
      "g"
    );
    var EXPRESSION_DOUBLE_SYLLABIC_FOUR = /[^s]ia/;
    var EXPRESSION_SINGLE = new RegExp(
      "^(un|fore|ware|none?|out|post|sub|pre|pro|dis|side)|(ly|less|some|ful|ers?|ness|cians?|ments?|ettes?|villes?|ships?|sides?|ports?|shires?|tion(ed)?)$",
      "g"
    );
    var EXPRESSION_DOUBLE = new RegExp(
      "^(above|anti|ante|counter|hyper|afore|agri|infra|intra|inter|over|semi|ultra|under|extra|dia|micro|mega|kilo|pico|nano|macro)|(fully|berry|woman|women)$",
      "g"
    );
    var EXPRESSION_TRIPLE = /(ology|ologist|onomy|onomist)$/g;
    var SPLIT = /\b/g;
    var EXPRESSION_NONALPHABETIC = /[^a-z]/g;
    function syllables(value) {
      var values = normalize(String(value)).toLowerCase().split(SPLIT);
      var length = values.length;
      var index = -1;
      var total = 0;
      while (++index < length) {
        total += syllable(values[index].replace(EXPRESSION_NONALPHABETIC, ""));
      }
      return total;
    }
    function syllable(value) {
      var count = 0;
      var index;
      var length;
      var singular;
      var parts;
      var addOne;
      var subtractOne;
      if (value.length === 0) {
        return count;
      }
      if (value.length < 3) {
        return 1;
      }
      if (own.call(problematic, value)) {
        return problematic[value];
      }
      singular = pluralize(value, 1);
      if (own.call(problematic, singular)) {
        return problematic[singular];
      }
      addOne = returnFactory(1);
      subtractOne = returnFactory(-1);
      value = value.replace(EXPRESSION_TRIPLE, countFactory(3)).replace(EXPRESSION_DOUBLE, countFactory(2)).replace(EXPRESSION_SINGLE, countFactory(1));
      parts = value.split(/[^aeiouy]+/);
      index = -1;
      length = parts.length;
      while (++index < length) {
        if (parts[index] !== "") {
          count++;
        }
      }
      value.replace(EXPRESSION_MONOSYLLABIC_ONE, subtractOne).replace(EXPRESSION_MONOSYLLABIC_TWO, subtractOne);
      value.replace(EXPRESSION_DOUBLE_SYLLABIC_ONE, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_TWO, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_THREE, addOne).replace(EXPRESSION_DOUBLE_SYLLABIC_FOUR, addOne);
      return count || 1;
      function countFactory(addition) {
        return counter;
        function counter() {
          count += addition;
          return "";
        }
      }
      function returnFactory(addition) {
        return returner;
        function returner($0) {
          count += addition;
          return $0;
        }
      }
    }
  }
});

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SmartWritingCompanion
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/types/settings.ts
var DEFAULT_SETTINGS = {
  llm: {
    preferLocal: true,
    ollamaBaseUrl: "http://localhost:11434",
    ollamaModel: "qwen2.5:7b",
    geminiApiKey: "",
    openaiApiKey: "",
    anthropicApiKey: "",
    defaultCloudProvider: "gemini",
    timeout: 3e4
  },
  analysis: {
    maxSentenceLength: 40,
    maxPassiveVoicePercent: 5,
    maxAdverbsPer1000: 20,
    fleschKincaidMin: 7,
    fleschKincaidMax: 9,
    filterWords: ["viu", "sentiu", "percebeu", "saw", "felt", "noticed"]
  },
  cleanup: {
    normalizeQuotes: true,
    normalizeDashes: true,
    normalizeEllipsis: true,
    normalizeWhitespace: true,
    removeControlChars: true,
    preserveMarkdown: true
  },
  translation: {
    targetLanguage: "pt",
    autoDetectProperNouns: true,
    preserveTerms: []
  },
  ui: {
    showOnStartup: true,
    autoAnalyze: true,
    showInlineSuggestions: true,
    compactMode: false
  }
};

// src/settings/SettingsTab.ts
var import_obsidian = require("obsidian");
var SWCSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Smart Writing Companion Settings" });
    containerEl.createEl("h3", { text: "LLM Configuration" });
    new import_obsidian.Setting(containerEl).setName("Prefer Local LLM (Ollama)").setDesc("Attempt to use Ochlama before falling back to cloud providers").addToggle((toggle) => toggle.setValue(this.plugin.settings.llm.preferLocal).onChange(async (value) => {
      this.plugin.settings.llm.preferLocal = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Ollama Base URL").setDesc("URL for your local Ollama instance").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.llm.ollamaBaseUrl).onChange(async (value) => {
      this.plugin.settings.llm.ollamaBaseUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Ollama Model").setDesc("Model to use with Ollama").addText((text) => text.setPlaceholder("qwen2.5:7b").setValue(this.plugin.settings.llm.ollamaModel).onChange(async (value) => {
      this.plugin.settings.llm.ollamaModel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Cloud Provider").setDesc("Provider to use if local LLM is unavailable or disabled").addDropdown((dropdown) => dropdown.addOption("gemini", "Google Gemini").addOption("openai", "OpenAI").addOption("anthropic", "Anthropic").setValue(this.plugin.settings.llm.defaultCloudProvider).onChange(async (value) => {
      this.plugin.settings.llm.defaultCloudProvider = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Gemini API Key").setDesc("API Key for Google Gemini").addText((text) => text.setPlaceholder("API Key").setValue(this.plugin.settings.llm.geminiApiKey).onChange(async (value) => {
      this.plugin.settings.llm.geminiApiKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Analysis Thresholds" });
    new import_obsidian.Setting(containerEl).setName("Max Sentence Length").setDesc("Sentences longer than this will be flagged").addText((text) => text.setPlaceholder("40").setValue(String(this.plugin.settings.analysis.maxSentenceLength)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num)) {
        this.plugin.settings.analysis.maxSentenceLength = num;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "Auto-Cleanup" });
    new import_obsidian.Setting(containerEl).setName("Normalize Quotes").setDesc("Convert straight quotes to curly quotes").addToggle((toggle) => toggle.setValue(this.plugin.settings.cleanup.normalizeQuotes).onChange(async (value) => {
      this.plugin.settings.cleanup.normalizeQuotes = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/views/CompanionView.ts
var import_obsidian2 = require("obsidian");
var VIEW_TYPE_COMPANION = "smart-writing-companion-view";
var CompanionView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.debouncedAnalyze = (0, import_obsidian2.debounce)((text) => this.runAnalysis(text), 1e3, true);
  }
  getViewType() {
    return VIEW_TYPE_COMPANION;
  }
  getDisplayText() {
    return "SmartWriting Companion";
  }
  async onOpen() {
    const container = this.containerEl;
    container.empty();
    this.renderInitial(container);
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => this.checkActiveFile()));
    this.registerEvent(this.app.workspace.on("editor-change", (editor) => {
      this.debouncedAnalyze(editor.getValue());
    }));
    this.checkActiveFile();
  }
  renderInitial(container) {
    container.innerHTML = `
    <div class="sidebar-wrapper">
        <aside class="sidebar">
            <div class="swc-companion">
                
                <!-- HEADER -->
                <header class="swc-header">
                    <div class="swc-header__left">
                        <span class="swc-header__icon">\u270F\uFE0F</span>
                        <h1 class="swc-header__title">Smart Writing</h1>
                    </div>
                </header>

                <!-- DOCUMENT CARD -->
                <div class="swc-document-card">
                    <div class="swc-document-card__filename">
                        <span class="swc-document-card__icon">\u{1F4C4}</span>
                        <span>--</span>
                    </div>
                    <div class="swc-document-card__stats">-</div>
                </div>

                <!-- READABILITY SECTION -->
                <section class="swc-section" id="readabilitySection">
                    <div class="swc-section__header" data-section="readabilitySection">
                        <svg class="swc-section__chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                        <span class="swc-section__title">Legibilidade</span>
                        <span class="swc-section__badge">-</span>
                    </div>
                    <div class="swc-section__content">
                        <div class="swc-meter">
                            <div class="swc-meter__header">
                                <span class="swc-meter__label">Flesch-Kincaid</span>
                                <span class="swc-meter__value">-</span>
                            </div>
                            <div class="swc-meter__track">
                                <div class="swc-meter__fill" style="width: 0%;"></div>
                            </div>
                            <div class="swc-meter__hint">Ideal: 7-9</div>
                            <div class="swc-meter__tooltip" style="display:none;">Metrics</div>
                        </div>

                        <div class="swc-metric">
                            <div class="swc-metric__dot"></div>
                            <span class="swc-metric__label">Voz passiva</span>
                            <span class="swc-metric__value">-</span>
                        </div>
                        <div class="swc-metric">
                            <div class="swc-metric__dot"></div>
                            <span class="swc-metric__label">Adv\xE9rbios</span>
                            <span class="swc-metric__value">-</span>
                        </div>
                        <div class="swc-metric">
                            <div class="swc-metric__dot"></div>
                            <span class="swc-metric__label">Frases longas</span>
                            <span class="swc-metric__value">-</span>
                        </div>
                    </div>
                </section>

                <!-- ACTION GRID -->
                <div class="swc-actions">
                    <div class="swc-actions__grid">
                        <button class="swc-action-btn swc-action-btn--primary">
                            <span class="swc-action-btn__icon">\u{1F50D}</span>
                            <span>Analisar Agora</span>
                        </button>
                    </div>
                </div>

            </div>
        </aside>
    </div>
		`;
    this.containerEl.querySelectorAll(".swc-section__header").forEach((el) => {
      el.addEventListener("click", () => {
        const sectionId = el.getAttribute("data-section");
        if (sectionId) {
          const section = this.containerEl.querySelector(`#${sectionId}`);
          if (section) {
            section.classList.toggle("swc-section--collapsed");
          }
        }
      });
    });
  }
  async checkActiveFile() {
    const file = this.app.workspace.getActiveFile();
    if (file instanceof import_obsidian2.TFile && (file.extension === "md" || file.extension === "txt")) {
      const content = await this.app.vault.read(file);
      this.updateDocumentInfo(file);
      this.runAnalysis(content);
    }
  }
  updateDocumentInfo(file) {
    const nameEl = this.containerEl.querySelector(".swc-document-card__filename span:nth-child(2)");
    if (nameEl)
      nameEl.textContent = file.name;
  }
  async runAnalysis(text) {
    if (!text)
      return;
    const results = this.plugin.analysisService.analyze(text);
    this.updateUI(results);
  }
  updateUI(results) {
    const statsEl = this.containerEl.querySelector(".swc-document-card__stats");
    if (statsEl) {
      statsEl.textContent = `${results.stats.words.toLocaleString()} palavras \u2022 ${results.stats.readingTimeMinutes} min leitura`;
    }
    const fkValue = this.containerEl.querySelector(".swc-meter__value");
    const fkFill = this.containerEl.querySelector(".swc-meter__fill");
    if (fkValue)
      fkValue.textContent = results.readability.fleschKincaid.toString();
    if (fkFill) {
      const fk = results.readability.fleschKincaid;
      const percent = Math.round(100 * (1 / (1 + Math.exp(-(fk - 8) / 3))));
      fkFill.style.width = `${percent}%`;
      fkFill.className = "swc-meter__fill";
      if (results.readability.fleschKincaid >= 7 && results.readability.fleschKincaid <= 9) {
        fkFill.classList.add("swc-meter__fill--good");
      } else if (results.readability.fleschKincaid < 5 || results.readability.fleschKincaid > 12) {
        fkFill.classList.add("swc-meter__fill--bad");
      } else {
        fkFill.classList.add("swc-meter__fill--ok");
      }
      const tooltip = this.containerEl.querySelector(".swc-meter__tooltip");
      if (tooltip) {
        tooltip.textContent = `Flesch ${results.readability.fleschKincaid}, F-Read ${results.readability.fleschReadingEase}, Gunning ${results.readability.gunningFog}, SMOG ${results.readability.smog}`;
        const parent = fkFill.parentElement;
        if (parent) {
          parent.addEventListener("mouseenter", () => {
            if (tooltip)
              tooltip.style.display = "block";
          });
          parent.addEventListener("mouseleave", () => {
            if (tooltip)
              tooltip.style.display = "none";
          });
        }
      }
    }
    this.updateMetric(
      "Voz passiva",
      `${results.style.passiveVoicePercent.toFixed(1)}%`,
      results.style.passiveVoicePercent > this.plugin.settings.analysis.maxPassiveVoicePercent ? "bad" : "good"
    );
    this.updateMetric(
      "Adv\xE9rbios",
      `${results.style.adverbsPer1000.toFixed(0)}/1000`,
      results.style.adverbsPer1000 > this.plugin.settings.analysis.maxAdverbsPer1000 ? "ok" : "good"
    );
    this.updateMetric(
      "Frases longas",
      results.style.longSentenceCount.toString(),
      results.style.longSentenceCount > 0 ? "bad" : "good"
    );
  }
  updateMetric(label, value, status) {
    const metrics = this.containerEl.querySelectorAll(".swc-metric");
    for (let i = 0; i < metrics.length; i++) {
      const metric = metrics[i];
      const labelEl = metric.querySelector(".swc-metric__label");
      if (labelEl && labelEl.textContent === label) {
        const valueEl = metric.querySelector(".swc-metric__value");
        const dotEl = metric.querySelector(".swc-metric__dot");
        if (valueEl)
          valueEl.textContent = value;
        if (dotEl) {
          dotEl.className = "swc-metric__dot";
          dotEl.classList.add(`swc-metric__dot--${status}`);
        }
        break;
      }
    }
  }
};

// src/analyzers/StatisticsAnalyzer.ts
var StatisticsAnalyzer = class {
  analyze(text) {
    const words = this.countWords(text);
    const sentences = this.countSentences(text);
    const paragraphs = this.countParagraphs(text);
    const characters = text.length;
    const charactersNoSpaces = text.replace(/\s/g, "").length;
    const readingTimeMinutes = this.calculateReadingTime(words);
    return {
      words,
      characters,
      charactersNoSpaces,
      sentences,
      paragraphs,
      readingTimeMinutes
    };
  }
  countWords(text) {
    const cleanText = this.stripMarkdown(text);
    if (!cleanText.trim())
      return 0;
    return (cleanText.match(/[\p{L}\p{N}'’-]+/gu) || []).length;
  }
  countSentences(text) {
    const cleanText = this.stripMarkdown(text);
    if (!cleanText.trim())
      return 0;
    const sentences = cleanText.split(/[.?!]+(\s|$)/).filter((s) => s.trim().length > 0);
    return sentences.length;
  }
  countParagraphs(text) {
    return text.split(/\n\s*\n/).filter((p) => p.trim().length > 0).length;
  }
  calculateReadingTime(words) {
    return Math.ceil(words / 200);
  }
  stripMarkdown(text) {
    const clean = text.replace(/^#+\s+/gm, "").replace(/(\*\*|__)(.*?)\1/g, "$2").replace(/(\*|_)(.*?)\1/g, "$2").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/!\[([^\]]*)\]\([^)]+\)/g, "").replace(/^>\s+/gm, "").replace(/```[\s\S]*?```/g, "").replace(/`([^`]+)`/g, "$1");
    return clean;
  }
};

// src/analyzers/ReadabilityAnalyzer.ts
var syllableLib = null;
try {
  syllableLib = require_syllable();
} catch (e) {
  syllableLib = null;
}
var ReadabilityAnalyzer = class {
  analyze(text, words, sentences) {
    if (words === 0 || sentences === 0) {
      return {
        fleschKincaid: 0,
        fleschReadingEase: 0,
        gunningFog: 0,
        smog: 0,
        colemanLiau: 0,
        automatedReadability: 0,
        daleChall: 0
      };
    }
    const syllables = this.countTotalSyllables(text);
    const complexWords = this.countComplexWords(text);
    const characters = text.replace(/\s/g, "").length;
    const polysyllables = this.countPolysyllables(text);
    const wordsPerSentence = words / sentences;
    const syllablesPerWord = syllables / words;
    const lettersPer100Words = characters / words * 100;
    const sentencesPer100Words = sentences / words * 100;
    const fleschKincaid = 0.39 * wordsPerSentence + 11.8 * syllablesPerWord - 15.59;
    const fleschReadingEase = 206.835 - 1.015 * wordsPerSentence - 84.6 * syllablesPerWord;
    const gunningFog = 0.4 * (wordsPerSentence + 100 * (complexWords / words));
    const smog = 1.043 * Math.sqrt(polysyllables * (30 / sentences)) + 3.1291;
    const colemanLiau = 0.0588 * lettersPer100Words - 0.296 * sentencesPer100Words - 15.8;
    const automatedReadability = 4.71 * (characters / words) + 0.5 * wordsPerSentence - 21.43;
    const difficultPercent = complexWords / words * 100;
    let daleChall = 0.1579 * difficultPercent + 0.0496 * wordsPerSentence;
    if (difficultPercent > 5) {
      daleChall += 3.6365;
    }
    return {
      fleschKincaid: Number(fleschKincaid.toFixed(1)),
      fleschReadingEase: Number(fleschReadingEase.toFixed(1)),
      gunningFog: Number(gunningFog.toFixed(1)),
      smog: Number(smog.toFixed(1)),
      colemanLiau: Number(colemanLiau.toFixed(1)),
      automatedReadability: Number(automatedReadability.toFixed(1)),
      daleChall: Number(daleChall.toFixed(1))
    };
  }
  countSyllables(word) {
    if (syllableLib) {
      try {
        return Math.max(1, syllableLib(word));
      } catch (_e) {
      }
    }
    word = word.toLowerCase().replace(/[^a-záéíóúâêîôûãõàèìòùäëïöü]/g, "");
    if (word.length <= 3)
      return 1;
    const matches = word.match(/[aeiouyáéíóúâêîôûãõàèìòùäëïöü]+/g);
    return matches ? matches.length : 1;
  }
  countTotalSyllables(text) {
    const words = text.match(/[\p{L}\p{N}']+/gu) || [];
    return words.reduce((sum, word) => sum + this.countSyllables(word), 0);
  }
  countComplexWords(text) {
    const words = text.match(/[\p{L}\p{N}']+/gu) || [];
    return words.filter((word) => this.countSyllables(word) >= 3).length;
  }
  countPolysyllables(text) {
    const words = text.match(/[\p{L}\p{N}']+/gu) || [];
    return words.filter((word) => this.countSyllables(word) >= 3).length;
  }
};

// src/analyzers/StyleAnalyzer.ts
var StyleAnalyzer = class {
  analyze(text) {
    const passiveVoice = this.findPassiveVoice(text);
    const adverbs = this.findAdverbs(text);
    const filterWords = this.findFilterWords(text);
    const longSentences = this.findLongSentences(text);
    const passiveVoiceCount = passiveVoice.length;
    const adverbCount = adverbs.length;
    const filterWordCount = filterWords.length;
    const longSentenceCount = longSentences.length;
    const sentences = text.split(/[.?!]+(\s|$)/).filter((s) => s.trim().length > 0);
    const words = text.match(/[\p{L}\p{N}'’-]+/gu) || [];
    const passiveVoicePercent = sentences.length > 0 ? passiveVoiceCount / sentences.length * 100 : 0;
    const adverbsPer1000 = words.length > 0 ? adverbCount / words.length * 1e3 : 0;
    const averageSentenceLength = sentences.length > 0 ? words.length / sentences.length : 0;
    return {
      passiveVoiceCount,
      passiveVoicePercent,
      adverbCount,
      adverbsPer1000,
      filterWordCount,
      longSentenceCount,
      averageSentenceLength,
      issues: [...passiveVoice, ...adverbs, ...filterWords, ...longSentences]
    };
  }
  findPassiveVoice(text) {
    const issues = [];
    const ptPattern = /\b(foi|foram|é|são|era|eram|será|serão|sido|sendo)\s+(\w+(ado|ido|to))\b/gi;
    const enPattern = /\b(was|were|is|are|been|being)\s+(\w+(ed|en|own|ung))\b/gi;
    let match;
    while ((match = ptPattern.exec(text)) !== null) {
      issues.push({
        type: "passive-voice",
        text: match[0],
        position: { start: match.index, end: match.index + match[0].length },
        severity: "info",
        suggestion: "Consider rewriting in active voice."
      });
    }
    while ((match = enPattern.exec(text)) !== null) {
      issues.push({
        type: "passive-voice",
        text: match[0],
        position: { start: match.index, end: match.index + match[0].length },
        severity: "info",
        suggestion: "Consider rewriting in active voice."
      });
    }
    return issues;
  }
  findAdverbs(text) {
    const issues = [];
    const pattern = /\b\w+(mente|ly)\b/gi;
    const exclusions = /* @__PURE__ */ new Set([
      "only",
      "early",
      "daily",
      "friendly",
      "likely",
      "ugly",
      "holy",
      "family",
      "silly",
      "lovely",
      "simplesmente",
      "realmente"
      // Some common PT ones might be debatable, but let's stick to basic structural check
    ]);
    let match;
    while ((match = pattern.exec(text)) !== null) {
      if (exclusions.has(match[0].toLowerCase()))
        continue;
      issues.push({
        type: "adverb",
        text: match[0],
        position: { start: match.index, end: match.index + match[0].length },
        severity: "info",
        suggestion: "Is this adverb necessary? Can a stronger verb be used?"
      });
    }
    return issues;
  }
  findFilterWords(text) {
    const issues = [];
    const filterWords = [
      "viu",
      "sentiu",
      "percebeu",
      "olhou",
      "notou",
      "ouviu",
      "saw",
      "felt",
      "noticed",
      "looked",
      "realized",
      "heard"
    ];
    const pattern = new RegExp(`\\b(${filterWords.join("|")})\\b`, "gi");
    let match;
    while ((match = pattern.exec(text)) !== null) {
      issues.push({
        type: "filter-word",
        text: match[0],
        position: { start: match.index, end: match.index + match[0].length },
        severity: "info",
        suggestion: "Filter word: creates distance. Describe the sensation directly."
      });
    }
    return issues;
  }
  findLongSentences(text, threshold = 40) {
    const issues = [];
    const sentencesMatches = text.matchAll(/[^.?!]+[.?!]+(\s|$)/g);
    for (const match of sentencesMatches) {
      const sentence = match[0];
      const wordCount = (sentence.match(/[\p{L}\p{N}'’-]+/gu) || []).length;
      if (wordCount > threshold) {
        issues.push({
          type: "long-sentence",
          text: sentence.trim(),
          position: { start: match.index || 0, end: (match.index || 0) + sentence.length },
          severity: "warning",
          suggestion: `Long sentence (${wordCount} words). Consider splitting.`
        });
      }
    }
    return issues;
  }
};

// src/analyzers/FictionAnalyzer.ts
var FictionAnalyzer = class {
  analyze(text) {
    const dialogStats = this.analyzeDialogue(text);
    const scenes = this.detectScenes(text);
    const averageSceneLength = scenes.length > 0 ? scenes.reduce((sum, s) => sum + s.wordCount, 0) / scenes.length : text.length > 0 ? (text.match(/[\p{L}\p{N}'’-]+/gu) || []).length : 0;
    return {
      dialogueRatio: dialogStats.ratio,
      dialogueWords: dialogStats.dialogueWords,
      narrativeWords: dialogStats.narrativeWords,
      sceneCount: scenes.length,
      averageSceneLength
    };
  }
  analyzeDialogue(text) {
    let dialogueWords = 0;
    let narrativeWords = 0;
    const quoteMatches = text.matchAll(/["“«]([^"”»]+)["”»]/g);
    let cleanedTextForNarrative = text;
    for (const match of quoteMatches) {
      const words = (match[1].match(/[\p{L}\p{N}'’-]+/gu) || []).length;
      dialogueWords += words;
      cleanedTextForNarrative = cleanedTextForNarrative.replace(match[0], " ");
    }
    const dashMatches = text.matchAll(/(^|\n)\s*—([^\n]+)/g);
    for (const match of dashMatches) {
      const words = (match[2].match(/[\p{L}\p{N}'’-]+/gu) || []).length;
      dialogueWords += words;
      cleanedTextForNarrative = cleanedTextForNarrative.replace(match[0], " ");
    }
    narrativeWords = (cleanedTextForNarrative.match(/[\p{L}\p{N}'’-]+/gu) || []).length;
    const total = dialogueWords + narrativeWords;
    const ratio = total > 0 ? dialogueWords / total * 100 : 0;
    return { ratio, dialogueWords, narrativeWords };
  }
  detectScenes(text) {
    const sceneBreaks = [
      ...text.matchAll(/(\n\s*[*_]{3,}\s*\n)|(\n\s*#+\s+)/g)
    ];
    const scenes = [];
    let lastIndex = 0;
    for (const match of sceneBreaks) {
      const endIndex = match.index || text.length;
      const sceneText = text.slice(lastIndex, endIndex);
      const wordCount = (sceneText.match(/[\p{L}\p{N}'’-]+/gu) || []).length;
      if (wordCount > 10) {
        scenes.push({ start: lastIndex, end: endIndex, wordCount });
      }
      lastIndex = endIndex + match[0].length;
    }
    if (lastIndex < text.length) {
      const sceneText = text.slice(lastIndex);
      const wordCount = (sceneText.match(/[\p{L}\p{N}'’-]+/gu) || []).length;
      if (wordCount > 10) {
        scenes.push({ start: lastIndex, end: text.length, wordCount });
      }
    }
    return scenes;
  }
};

// src/analyzers/TextCleanup.ts
var TextCleanup = class {
  analyze(text) {
    const suggestions = [];
    this.checkRegex(text, /"|'/g, "quote", "Straight quotes used", suggestions);
    this.checkRegex(text, /--/g, "dash", "Double dash used (should be em-dash)", suggestions);
    this.checkRegex(text, /\.\.\./g, "ellipsis", "Three periods used (should be ellipsis char)", suggestions);
    this.checkRegex(text, /[ \t]+$/gm, "whitespace", "Trailing whitespace", suggestions);
    this.checkRegex(text, /  +/g, "whitespace", "Multiple spaces", suggestions);
    return {
      suggestions,
      stats: {
        quotes: suggestions.filter((s) => s.type === "quote").length,
        dashes: suggestions.filter((s) => s.type === "dash").length,
        ellipsis: suggestions.filter((s) => s.type === "ellipsis").length,
        whitespace: suggestions.filter((s) => s.type === "whitespace").length,
        controlChars: suggestions.filter((s) => s.type === "control-char").length,
        total: suggestions.length
      }
    };
  }
  clean(text) {
    let cleaned = text;
    cleaned = cleaned.replace(/(\s|^)"/g, "$1\u201C").replace(/"/g, "\u201D");
    cleaned = cleaned.replace(/(\s|^)'/g, "$1\u2018").replace(/'/g, "\u2019");
    cleaned = cleaned.replace(/ -- /g, " \u2014 ");
    cleaned = cleaned.replace(/--/g, "\u2014");
    cleaned = cleaned.replace(/\.\.\./g, "\u2026");
    cleaned = cleaned.replace(/[ \t]+$/gm, "");
    cleaned = cleaned.replace(/  +/g, " ");
    return cleaned;
  }
  checkRegex(text, regex, type, desc, suggestions) {
    let match;
    const re = new RegExp(regex);
    while ((match = re.exec(text)) !== null) {
      suggestions.push({
        id: `cleanup-${suggestions.length}`,
        type,
        original: match[0],
        replacement: "",
        // Would need specific logic to know *what* to replace with exactly in specific contexts
        position: { start: match.index, end: match.index + match[0].length },
        description: desc
      });
      if (!re.global)
        break;
    }
  }
  applySuggestions(text, suggestions) {
    const sorted = [...suggestions].sort((a, b) => b.position.start - a.position.start);
    let result = text;
    for (const suggestion of sorted) {
      const before = result.slice(0, suggestion.position.start);
      const after = result.slice(suggestion.position.end);
      result = before + suggestion.replacement + after;
    }
    return result;
  }
};

// src/services/AnalysisService.ts
var AnalysisService = class {
  constructor(settings) {
    this.settings = settings;
    this.statsAnalyzer = new StatisticsAnalyzer();
    this.readabilityAnalyzer = new ReadabilityAnalyzer();
    this.styleAnalyzer = new StyleAnalyzer();
    this.fictionAnalyzer = new FictionAnalyzer();
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  analyze(text) {
    const stats = this.statsAnalyzer.analyze(text);
    const readability = this.readabilityAnalyzer.analyze(text, stats.words, stats.sentences);
    const style = this.styleAnalyzer.analyze(text);
    const fiction = this.fictionAnalyzer.analyze(text);
    return {
      stats,
      readability,
      style,
      fiction,
      analyzedAt: new Date(),
      documentHash: this.simpleHash(text)
    };
  }
  simpleHash(text) {
    let hash = 0, i, chr;
    if (text.length === 0)
      return hash.toString();
    for (i = 0; i < text.length; i++) {
      chr = text.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }
    return hash.toString();
  }
};

// src/services/CleanupService.ts
var CleanupService = class {
  constructor(settings) {
    this.settings = settings;
    this.textCleanup = new TextCleanup();
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  analyze(text) {
    return this.textCleanup.analyze(text);
  }
  clean(text) {
    const cleaned = text;
    return this.textCleanup.clean(text);
  }
  applySuggestion(text, suggestion) {
    return this.textCleanup.applySuggestions(text, [suggestion]);
  }
};

// src/services/PersonaService.ts
var PersonaService = class {
  constructor(settings, gateway) {
    this.personas = {
      "booktuber": 'You are a lively, energetic BookTuber who reviews fiction. You focus on hooks, pacing, and "vibes". You use emoji and slang. You care if the book is "bingeable".',
      "hardcore": 'You are a hardcore sci-fi/fantasy reader. You obsess over worldbuilding consistency, magic systems, and logical plot progression. You hate plotholes and "hand-waving".',
      "casual": "You are a casual reader who reads for fun on the commute. You want simple, clear prose and engaging characters. You dislike confusion or purple prose."
    };
    this.settings = settings;
    this.gateway = gateway;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async evaluate(text, personaId) {
    const systemPrompt = this.personas[personaId];
    if (!systemPrompt) {
      throw new Error(`Persona ${personaId} not found`);
    }
    const prompt = `
Read the following text excerpt and evaluate it based on your persona.
Provide a JSON response with the following structure:
{
    "rating": (1-5 number),
    "summary": "One sentence summary of your impression",
    "strengths": ["point 1", "point 2"],
    "weaknesses": ["point 1", "point 2"],
    "fullEvaluation": "A paragraph explaining your thoughts in your persona's voice"
}

Text to evaluate:
---
${text}
---
`;
    try {
      const resultRaw = await this.gateway.complete(prompt, {
        systemPrompt
      });
      const jsonStr = resultRaw.replace(/```json/g, "").replace(/```/g, "").trim();
      const result = JSON.parse(jsonStr);
      return {
        personaId,
        personaName: personaId.charAt(0).toUpperCase() + personaId.slice(1),
        rating: result.rating,
        summary: result.summary,
        strengths: result.strengths,
        weaknesses: result.weaknesses,
        fullEvaluation: result.fullEvaluation,
        evaluatedAt: new Date()
      };
    } catch (error) {
      console.error("Persona evaluation failed", error);
      throw error;
    }
  }
};

// src/gateway/LLMGateway.ts
var import_obsidian3 = require("obsidian");
var LLMGateway = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async checkConnection() {
    if (this.settings.llm.preferLocal) {
      try {
        const response = await (0, import_obsidian3.requestUrl)({
          url: `${this.settings.llm.ollamaBaseUrl}/api/tags`,
          method: "GET",
          throw: false
        });
        if (response.status === 200) {
          return {
            provider: "ollama",
            isConnected: true,
            isLocal: true,
            modelName: this.settings.llm.ollamaModel,
            lastChecked: new Date()
          };
        }
      } catch (e) {
      }
    }
    const provider = this.settings.llm.defaultCloudProvider;
    const hasKey = this.getApiKey(provider);
    if (hasKey) {
      return {
        provider,
        isConnected: true,
        isLocal: false,
        modelName: provider,
        lastChecked: new Date()
      };
    }
    return {
      provider: null,
      isConnected: false,
      isLocal: false,
      modelName: null,
      lastChecked: new Date(),
      error: "No valid provider found"
    };
  }
  async complete(prompt, options) {
    const status = await this.checkConnection();
    if (!status.isConnected || !status.provider) {
      throw new Error("No LLM provider connected");
    }
    if (status.provider === "ollama") {
      return this.completeOllama(prompt, options);
    } else if (status.provider === "gemini") {
      return this.completeGemini(prompt, options);
    }
    throw new Error(`Provider ${status.provider} not yet implemented`);
  }
  async completeOllama(prompt, options) {
    const body = {
      model: this.settings.llm.ollamaModel,
      prompt,
      stream: false,
      options: {
        temperature: (options == null ? void 0 : options.temperature) || 0.7,
        num_predict: (options == null ? void 0 : options.maxTokens) || 2048
      },
      system: options == null ? void 0 : options.systemPrompt
    };
    try {
      const response = await (0, import_obsidian3.requestUrl)({
        url: `${this.settings.llm.ollamaBaseUrl}/api/generate`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      if (response.status === 200) {
        return JSON.parse(response.json).response;
      } else {
        throw new Error(`Ollama error: ${response.status}`);
      }
    } catch (error) {
      throw new Error(`Ollama connection failed: ${error}`);
    }
  }
  async completeGemini(prompt, options) {
    const model = "gemini-pro";
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${this.settings.llm.geminiApiKey}`;
    const body = {
      contents: [{
        parts: [{ text: ((options == null ? void 0 : options.systemPrompt) ? options.systemPrompt + "\\n\\n" : "") + prompt }]
      }],
      generationConfig: {
        temperature: (options == null ? void 0 : options.temperature) || 0.7,
        maxOutputTokens: (options == null ? void 0 : options.maxTokens) || 2048
      }
    };
    try {
      const response = await (0, import_obsidian3.requestUrl)({
        url,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      if (response.status === 200) {
        const data = response.json;
        return data.candidates[0].content.parts[0].text;
      } else {
        throw new Error(`Gemini error: ${response.status}`);
      }
    } catch (error) {
      throw new Error(`Gemini request failed: ${error}`);
    }
  }
  getApiKey(provider) {
    switch (provider) {
      case "gemini":
        return this.settings.llm.geminiApiKey;
      case "openai":
        return this.settings.llm.openaiApiKey;
      case "anthropic":
        return this.settings.llm.anthropicApiKey;
      default:
        return "";
    }
  }
};

// main.ts
var SmartWritingCompanion = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.analysisService = new AnalysisService(this.settings);
    this.cleanupService = new CleanupService(this.settings);
    this.llmGateway = new LLMGateway(this.settings);
    this.personaService = new PersonaService(this.settings, this.llmGateway);
    this.registerView(
      VIEW_TYPE_COMPANION,
      (leaf) => new CompanionView(leaf, this)
    );
    this.addRibbonIcon("book-open", "SmartWriting Companion", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-smart-writing-companion",
      name: "Open SmartWriting Companion",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new SWCSettingTab(this.app, this));
    this.registerEvent(this.app.workspace.on("file-open", (file) => {
      const leaf = this.app.workspace.getLeaf(false);
      if (leaf)
        this.addIconToHeader(leaf);
    }));
    this.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
      if (leaf)
        this.addIconToHeader(leaf);
    }));
    this.app.workspace.onLayoutReady(() => {
      this.app.workspace.iterateAllLeaves((leaf) => {
        this.addIconToHeader(leaf);
      });
    });
  }
  async onunload() {
  }
  addIconToHeader(leaf) {
    if (!leaf.view)
      return;
    if (leaf.view.getViewType() === "markdown") {
      const view = leaf.view;
      const existing = view.containerEl.querySelector(".swc-header-action");
      if (existing)
        return;
      const action = view.addAction("book-open", "Open SmartWriting Companion", () => {
        this.activateView();
      });
      action.classList.add("swc-header-action");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_COMPANION);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({ type: VIEW_TYPE_COMPANION, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
