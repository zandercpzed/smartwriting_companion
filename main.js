/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);

// main.ts
var main_exports = {};
__export(main_exports, {
  default: () => SmartWritingCompanion
});
module.exports = __toCommonJS(main_exports);
var import_obsidian4 = require("obsidian");

// src/types/settings.ts
var DEFAULT_SETTINGS = {
  llm: {
    preferLocal: true,
    ollamaBaseUrl: "http://localhost:11434",
    ollamaModel: "qwen2.5:7b",
    geminiApiKey: "",
    openaiApiKey: "",
    anthropicApiKey: "",
    defaultCloudProvider: "gemini",
    timeout: 3e4
  },
  analysis: {
    maxSentenceLength: 40,
    maxPassiveVoicePercent: 5,
    maxAdverbsPer1000: 20,
    fleschKincaidMin: 7,
    fleschKincaidMax: 9,
    filterWords: ["viu", "sentiu", "percebeu", "saw", "felt", "noticed"]
  },
  cleanup: {
    normalizeQuotes: true,
    normalizeDashes: true,
    normalizeEllipsis: true,
    normalizeWhitespace: true,
    removeControlChars: true,
    preserveMarkdown: true
  },
  translation: {
    targetLanguage: "pt",
    autoDetectProperNouns: true,
    preserveTerms: []
  },
  ui: {
    showOnStartup: true,
    autoAnalyze: true,
    showInlineSuggestions: true,
    compactMode: false
  }
};

// src/settings/SettingsTab.ts
var import_obsidian = require("obsidian");
var SWCSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app, plugin) {
    super(app, plugin);
    this.plugin = plugin;
  }
  display() {
    const { containerEl } = this;
    containerEl.empty();
    containerEl.createEl("h2", { text: "Smart Writing Companion Settings" });
    containerEl.createEl("h3", { text: "LLM Configuration" });
    new import_obsidian.Setting(containerEl).setName("Prefer Local LLM (Ollama)").setDesc("Attempt to use Ochlama before falling back to cloud providers").addToggle((toggle) => toggle.setValue(this.plugin.settings.llm.preferLocal).onChange(async (value) => {
      this.plugin.settings.llm.preferLocal = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Ollama Base URL").setDesc("URL for your local Ollama instance").addText((text) => text.setPlaceholder("http://localhost:11434").setValue(this.plugin.settings.llm.ollamaBaseUrl).onChange(async (value) => {
      this.plugin.settings.llm.ollamaBaseUrl = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Ollama Model").setDesc("Model to use with Ollama").addText((text) => text.setPlaceholder("qwen2.5:7b").setValue(this.plugin.settings.llm.ollamaModel).onChange(async (value) => {
      this.plugin.settings.llm.ollamaModel = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Default Cloud Provider").setDesc("Provider to use if local LLM is unavailable or disabled").addDropdown((dropdown) => dropdown.addOption("gemini", "Google Gemini").addOption("openai", "OpenAI").addOption("anthropic", "Anthropic").setValue(this.plugin.settings.llm.defaultCloudProvider).onChange(async (value) => {
      this.plugin.settings.llm.defaultCloudProvider = value;
      await this.plugin.saveSettings();
    }));
    new import_obsidian.Setting(containerEl).setName("Gemini API Key").setDesc("API Key for Google Gemini").addText((text) => text.setPlaceholder("API Key").setValue(this.plugin.settings.llm.geminiApiKey).onChange(async (value) => {
      this.plugin.settings.llm.geminiApiKey = value;
      await this.plugin.saveSettings();
    }));
    containerEl.createEl("h3", { text: "Analysis Thresholds" });
    new import_obsidian.Setting(containerEl).setName("Max Sentence Length").setDesc("Sentences longer than this will be flagged").addText((text) => text.setPlaceholder("40").setValue(String(this.plugin.settings.analysis.maxSentenceLength)).onChange(async (value) => {
      const num = parseInt(value);
      if (!isNaN(num)) {
        this.plugin.settings.analysis.maxSentenceLength = num;
        await this.plugin.saveSettings();
      }
    }));
    containerEl.createEl("h3", { text: "Auto-Cleanup" });
    new import_obsidian.Setting(containerEl).setName("Normalize Quotes").setDesc("Convert straight quotes to curly quotes").addToggle((toggle) => toggle.setValue(this.plugin.settings.cleanup.normalizeQuotes).onChange(async (value) => {
      this.plugin.settings.cleanup.normalizeQuotes = value;
      await this.plugin.saveSettings();
    }));
  }
};

// src/views/CompanionView.ts
var import_obsidian2 = require("obsidian");
var VIEW_TYPE_COMPANION = "smart-writing-companion-view";
var CompanionView = class extends import_obsidian2.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.plugin = plugin;
    this.debouncedAnalyze = (0, import_obsidian2.debounce)((text) => this.runAnalysis(text), 1e3, true);
  }
  getViewType() {
    return VIEW_TYPE_COMPANION;
  }
  getDisplayText() {
    return "SmartWriting Companion";
  }
  async onOpen() {
    const container = this.containerEl;
    container.empty();
    this.renderInitial(container);
    this.registerEvent(this.app.workspace.on("active-leaf-change", () => this.checkActiveFile()));
    this.registerEvent(this.app.workspace.on("editor-change", (editor) => {
      this.debouncedAnalyze(editor.getValue());
    }));
    this.checkActiveFile();
  }
  renderInitial(container) {
    container.innerHTML = `
    <div class="sidebar-wrapper">
        <aside class="sidebar">
            <div class="swc-companion">
                
                <!-- HEADER -->
                <header class="swc-header">
                    <div class="swc-header__left">
                        <span class="swc-header__icon">\u270F\uFE0F</span>
                        <h1 class="swc-header__title">Smart Writing</h1>
                    </div>
                </header>

                <!-- DOCUMENT CARD -->
                <div class="swc-document-card">
                    <div class="swc-document-card__filename">
                        <span class="swc-document-card__icon">\u{1F4C4}</span>
                        <span>--</span>
                    </div>
                    <div class="swc-document-card__stats">-</div>
                </div>

                <!-- READABILITY SECTION -->
                <section class="swc-section" id="readabilitySection">
                    <div class="swc-section__header" data-section="readabilitySection">
                        <svg class="swc-section__chevron" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                            <polyline points="6 9 12 15 18 9"></polyline>
                        </svg>
                        <span class="swc-section__title">Legibilidade</span>
                        <span class="swc-section__badge">-</span>
                    </div>
                    <div class="swc-section__content">
                        <div class="swc-meter">
                            <div class="swc-meter__header">
                                <span class="swc-meter__label">Flesch-Kincaid</span>
                                <span class="swc-meter__value">-</span>
                            </div>
                            <div class="swc-meter__track">
                                <div class="swc-meter__fill" style="width: 0%;"></div>
                            </div>
                            <div class="swc-meter__hint">Ideal: 7-9</div>
                        </div>

                        <div class="swc-metric">
                            <div class="swc-metric__dot"></div>
                            <span class="swc-metric__label">Voz passiva</span>
                            <span class="swc-metric__value">-</span>
                        </div>
                        <div class="swc-metric">
                            <div class="swc-metric__dot"></div>
                            <span class="swc-metric__label">Adv\xE9rbios</span>
                            <span class="swc-metric__value">-</span>
                        </div>
                        <div class="swc-metric">
                            <div class="swc-metric__dot"></div>
                            <span class="swc-metric__label">Frases longas</span>
                            <span class="swc-metric__value">-</span>
                        </div>
                    </div>
                </section>

                <!-- ACTION GRID -->
                <div class="swc-actions">
                    <div class="swc-actions__grid">
                        <button class="swc-action-btn swc-action-btn--primary">
                            <span class="swc-action-btn__icon">\u{1F50D}</span>
                            <span>Analisar Agora</span>
                        </button>
                    </div>
                </div>

            </div>
        </aside>
    </div>
		`;
    this.containerEl.querySelectorAll(".swc-section__header").forEach((el) => {
      el.addEventListener("click", () => {
        const sectionId = el.getAttribute("data-section");
        if (sectionId) {
          const section = this.containerEl.querySelector(`#${sectionId}`);
          if (section) {
            section.classList.toggle("swc-section--collapsed");
          }
        }
      });
    });
  }
  async checkActiveFile() {
    const file = this.app.workspace.getActiveFile();
    if (file instanceof import_obsidian2.TFile && (file.extension === "md" || file.extension === "txt")) {
      const content = await this.app.vault.read(file);
      this.updateDocumentInfo(file);
      this.runAnalysis(content);
    }
  }
  updateDocumentInfo(file) {
    const nameEl = this.containerEl.querySelector(".swc-document-card__filename span:nth-child(2)");
    if (nameEl)
      nameEl.textContent = file.name;
  }
  async runAnalysis(text) {
    if (!text)
      return;
    const results = this.plugin.analysisService.analyze(text);
    this.updateUI(results);
  }
  updateUI(results) {
    const statsEl = this.containerEl.querySelector(".swc-document-card__stats");
    if (statsEl) {
      statsEl.textContent = `${results.stats.words.toLocaleString()} palavras \u2022 ${results.stats.readingTimeMinutes} min leitura`;
    }
    const fkValue = this.containerEl.querySelector(".swc-meter__value");
    const fkFill = this.containerEl.querySelector(".swc-meter__fill");
    if (fkValue)
      fkValue.textContent = results.readability.fleschKincaid.toString();
    if (fkFill) {
      const percent = Math.min(100, Math.max(0, results.readability.fleschKincaid / 12 * 100));
      fkFill.style.width = `${percent}%`;
      fkFill.className = "swc-meter__fill";
      if (results.readability.fleschKincaid >= 7 && results.readability.fleschKincaid <= 9) {
        fkFill.classList.add("swc-meter__fill--good");
      } else if (results.readability.fleschKincaid < 5 || results.readability.fleschKincaid > 12) {
        fkFill.classList.add("swc-meter__fill--bad");
      } else {
        fkFill.classList.add("swc-meter__fill--ok");
      }
    }
    this.updateMetric(
      "Voz passiva",
      `${results.style.passiveVoicePercent.toFixed(1)}%`,
      results.style.passiveVoicePercent > this.plugin.settings.analysis.maxPassiveVoicePercent ? "bad" : "good"
    );
    this.updateMetric(
      "Adv\xE9rbios",
      `${results.style.adverbsPer1000.toFixed(0)}/1000`,
      results.style.adverbsPer1000 > this.plugin.settings.analysis.maxAdverbsPer1000 ? "ok" : "good"
    );
    this.updateMetric(
      "Frases longas",
      results.style.longSentenceCount.toString(),
      results.style.longSentenceCount > 0 ? "bad" : "good"
    );
  }
  updateMetric(label, value, status) {
    const metrics = this.containerEl.querySelectorAll(".swc-metric");
    for (let i = 0; i < metrics.length; i++) {
      const metric = metrics[i];
      const labelEl = metric.querySelector(".swc-metric__label");
      if (labelEl && labelEl.textContent === label) {
        const valueEl = metric.querySelector(".swc-metric__value");
        const dotEl = metric.querySelector(".swc-metric__dot");
        if (valueEl)
          valueEl.textContent = value;
        if (dotEl) {
          dotEl.className = "swc-metric__dot";
          dotEl.classList.add(`swc-metric__dot--${status}`);
        }
        break;
      }
    }
  }
};

// src/analyzers/StatisticsAnalyzer.ts
var StatisticsAnalyzer = class {
  analyze(text) {
    const words = this.countWords(text);
    const sentences = this.countSentences(text);
    const paragraphs = this.countParagraphs(text);
    const characters = text.length;
    const charactersNoSpaces = text.replace(/\s/g, "").length;
    const readingTimeMinutes = this.calculateReadingTime(words);
    return {
      words,
      characters,
      charactersNoSpaces,
      sentences,
      paragraphs,
      readingTimeMinutes
    };
  }
  countWords(text) {
    const cleanText = this.stripMarkdown(text);
    if (!cleanText.trim())
      return 0;
    return (cleanText.match(/[\p{L}\p{N}'’-]+/gu) || []).length;
  }
  countSentences(text) {
    const cleanText = this.stripMarkdown(text);
    if (!cleanText.trim())
      return 0;
    const sentences = cleanText.split(/[.?!]+(\s|$)/).filter((s) => s.trim().length > 0);
    return sentences.length;
  }
  countParagraphs(text) {
    return text.split(/\n\s*\n/).filter((p) => p.trim().length > 0).length;
  }
  calculateReadingTime(words) {
    return Math.ceil(words / 200);
  }
  stripMarkdown(text) {
    const clean = text.replace(/^#+\s+/gm, "").replace(/(\*\*|__)(.*?)\1/g, "$2").replace(/(\*|_)(.*?)\1/g, "$2").replace(/\[([^\]]+)\]\([^)]+\)/g, "$1").replace(/!\[([^\]]*)\]\([^)]+\)/g, "").replace(/^>\s+/gm, "").replace(/```[\s\S]*?```/g, "").replace(/`([^`]+)`/g, "$1");
    return clean;
  }
};

// src/analyzers/ReadabilityAnalyzer.ts
var ReadabilityAnalyzer = class {
  analyze(text, words, sentences) {
    if (words === 0 || sentences === 0) {
      return {
        fleschKincaid: 0,
        fleschReadingEase: 0,
        gunningFog: 0,
        smog: 0,
        colemanLiau: 0,
        automatedReadability: 0,
        daleChall: 0
      };
    }
    const syllables = this.countTotalSyllables(text);
    const complexWords = this.countComplexWords(text);
    const characters = text.replace(/\s/g, "").length;
    const polysyllables = this.countPolysyllables(text);
    const wordsPerSentence = words / sentences;
    const syllablesPerWord = syllables / words;
    const lettersPer100Words = characters / words * 100;
    const sentencesPer100Words = sentences / words * 100;
    const fleschKincaid = 0.39 * wordsPerSentence + 11.8 * syllablesPerWord - 15.59;
    const fleschReadingEase = 206.835 - 1.015 * wordsPerSentence - 84.6 * syllablesPerWord;
    const gunningFog = 0.4 * (wordsPerSentence + 100 * (complexWords / words));
    const smog = 1.043 * Math.sqrt(polysyllables * (30 / sentences)) + 3.1291;
    const colemanLiau = 0.0588 * lettersPer100Words - 0.296 * sentencesPer100Words - 15.8;
    const automatedReadability = 4.71 * (characters / words) + 0.5 * wordsPerSentence - 21.43;
    const difficultPercent = complexWords / words * 100;
    let daleChall = 0.1579 * difficultPercent + 0.0496 * wordsPerSentence;
    if (difficultPercent > 5) {
      daleChall += 3.6365;
    }
    return {
      fleschKincaid: Number(fleschKincaid.toFixed(1)),
      fleschReadingEase: Number(fleschReadingEase.toFixed(1)),
      gunningFog: Number(gunningFog.toFixed(1)),
      smog: Number(smog.toFixed(1)),
      colemanLiau: Number(colemanLiau.toFixed(1)),
      automatedReadability: Number(automatedReadability.toFixed(1)),
      daleChall: Number(daleChall.toFixed(1))
    };
  }
  countSyllables(word) {
    word = word.toLowerCase().replace(/[^a-z]/g, "");
    if (word.length <= 3)
      return 1;
    const matches = word.match(/[aeiouyáéíóúâêîôûãõàèìòùäëïöü]+/g);
    return matches ? matches.length : 1;
  }
  countTotalSyllables(text) {
    const words = text.match(/[\p{L}\p{N}']+/gu) || [];
    return words.reduce((sum, word) => sum + this.countSyllables(word), 0);
  }
  countComplexWords(text) {
    const words = text.match(/[\p{L}\p{N}']+/gu) || [];
    return words.filter((word) => this.countSyllables(word) >= 3).length;
  }
  countPolysyllables(text) {
    const words = text.match(/[\p{L}\p{N}']+/gu) || [];
    return words.filter((word) => this.countSyllables(word) >= 3).length;
  }
};

// src/analyzers/StyleAnalyzer.ts
var StyleAnalyzer = class {
  analyze(text) {
    const passiveVoice = this.findPassiveVoice(text);
    const adverbs = this.findAdverbs(text);
    const filterWords = this.findFilterWords(text);
    const longSentences = this.findLongSentences(text);
    const passiveVoiceCount = passiveVoice.length;
    const adverbCount = adverbs.length;
    const filterWordCount = filterWords.length;
    const longSentenceCount = longSentences.length;
    const sentences = text.split(/[.?!]+(\s|$)/).filter((s) => s.trim().length > 0);
    const words = text.match(/[\p{L}\p{N}'’-]+/gu) || [];
    const passiveVoicePercent = sentences.length > 0 ? passiveVoiceCount / sentences.length * 100 : 0;
    const adverbsPer1000 = words.length > 0 ? adverbCount / words.length * 1e3 : 0;
    const averageSentenceLength = sentences.length > 0 ? words.length / sentences.length : 0;
    return {
      passiveVoiceCount,
      passiveVoicePercent,
      adverbCount,
      adverbsPer1000,
      filterWordCount,
      longSentenceCount,
      averageSentenceLength,
      issues: [...passiveVoice, ...adverbs, ...filterWords, ...longSentences]
    };
  }
  findPassiveVoice(text) {
    const issues = [];
    const ptPattern = /\b(foi|foram|é|são|era|eram|será|serão|sido|sendo)\s+(\w+(ado|ido|to))\b/gi;
    const enPattern = /\b(was|were|is|are|been|being)\s+(\w+(ed|en|own|ung))\b/gi;
    let match;
    while ((match = ptPattern.exec(text)) !== null) {
      issues.push({
        type: "passive-voice",
        text: match[0],
        position: { start: match.index, end: match.index + match[0].length },
        severity: "info",
        suggestion: "Consider rewriting in active voice."
      });
    }
    while ((match = enPattern.exec(text)) !== null) {
      issues.push({
        type: "passive-voice",
        text: match[0],
        position: { start: match.index, end: match.index + match[0].length },
        severity: "info",
        suggestion: "Consider rewriting in active voice."
      });
    }
    return issues;
  }
  findAdverbs(text) {
    const issues = [];
    const pattern = /\b\w+(mente|ly)\b/gi;
    const exclusions = /* @__PURE__ */ new Set([
      "only",
      "early",
      "daily",
      "friendly",
      "likely",
      "ugly",
      "holy",
      "family",
      "silly",
      "lovely",
      "simplesmente",
      "realmente"
      // Some common PT ones might be debatable, but let's stick to basic structural check
    ]);
    let match;
    while ((match = pattern.exec(text)) !== null) {
      if (exclusions.has(match[0].toLowerCase()))
        continue;
      issues.push({
        type: "adverb",
        text: match[0],
        position: { start: match.index, end: match.index + match[0].length },
        severity: "info",
        suggestion: "Is this adverb necessary? Can a stronger verb be used?"
      });
    }
    return issues;
  }
  findFilterWords(text) {
    const issues = [];
    const filterWords = [
      "viu",
      "sentiu",
      "percebeu",
      "olhou",
      "notou",
      "ouviu",
      "saw",
      "felt",
      "noticed",
      "looked",
      "realized",
      "heard"
    ];
    const pattern = new RegExp(`\\b(${filterWords.join("|")})\\b`, "gi");
    let match;
    while ((match = pattern.exec(text)) !== null) {
      issues.push({
        type: "filter-word",
        text: match[0],
        position: { start: match.index, end: match.index + match[0].length },
        severity: "info",
        suggestion: "Filter word: creates distance. Describe the sensation directly."
      });
    }
    return issues;
  }
  findLongSentences(text, threshold = 40) {
    const issues = [];
    const sentencesMatches = text.matchAll(/[^.?!]+[.?!]+(\s|$)/g);
    for (const match of sentencesMatches) {
      const sentence = match[0];
      const wordCount = (sentence.match(/[\p{L}\p{N}'’-]+/gu) || []).length;
      if (wordCount > threshold) {
        issues.push({
          type: "long-sentence",
          text: sentence.trim(),
          position: { start: match.index || 0, end: (match.index || 0) + sentence.length },
          severity: "warning",
          suggestion: `Long sentence (${wordCount} words). Consider splitting.`
        });
      }
    }
    return issues;
  }
};

// src/analyzers/FictionAnalyzer.ts
var FictionAnalyzer = class {
  analyze(text) {
    const dialogStats = this.analyzeDialogue(text);
    const scenes = this.detectScenes(text);
    const averageSceneLength = scenes.length > 0 ? scenes.reduce((sum, s) => sum + s.wordCount, 0) / scenes.length : text.length > 0 ? (text.match(/[\p{L}\p{N}'’-]+/gu) || []).length : 0;
    return {
      dialogueRatio: dialogStats.ratio,
      dialogueWords: dialogStats.dialogueWords,
      narrativeWords: dialogStats.narrativeWords,
      sceneCount: scenes.length,
      averageSceneLength
    };
  }
  analyzeDialogue(text) {
    let dialogueWords = 0;
    let narrativeWords = 0;
    const quoteMatches = text.matchAll(/["“«]([^"”»]+)["”»]/g);
    let cleanedTextForNarrative = text;
    for (const match of quoteMatches) {
      const words = (match[1].match(/[\p{L}\p{N}'’-]+/gu) || []).length;
      dialogueWords += words;
      cleanedTextForNarrative = cleanedTextForNarrative.replace(match[0], " ");
    }
    const dashMatches = text.matchAll(/(^|\n)\s*—([^\n]+)/g);
    for (const match of dashMatches) {
      const words = (match[2].match(/[\p{L}\p{N}'’-]+/gu) || []).length;
      dialogueWords += words;
      cleanedTextForNarrative = cleanedTextForNarrative.replace(match[0], " ");
    }
    narrativeWords = (cleanedTextForNarrative.match(/[\p{L}\p{N}'’-]+/gu) || []).length;
    const total = dialogueWords + narrativeWords;
    const ratio = total > 0 ? dialogueWords / total * 100 : 0;
    return { ratio, dialogueWords, narrativeWords };
  }
  detectScenes(text) {
    const sceneBreaks = [
      ...text.matchAll(/(\n\s*[\*\-_]{3,}\s*\n)|(\n\s*#+\s+)/g)
    ];
    const scenes = [];
    let lastIndex = 0;
    for (const match of sceneBreaks) {
      const endIndex = match.index || text.length;
      const sceneText = text.slice(lastIndex, endIndex);
      const wordCount = (sceneText.match(/[\p{L}\p{N}'’-]+/gu) || []).length;
      if (wordCount > 10) {
        scenes.push({ start: lastIndex, end: endIndex, wordCount });
      }
      lastIndex = endIndex + match[0].length;
    }
    if (lastIndex < text.length) {
      const sceneText = text.slice(lastIndex);
      const wordCount = (sceneText.match(/[\p{L}\p{N}'’-]+/gu) || []).length;
      if (wordCount > 10) {
        scenes.push({ start: lastIndex, end: text.length, wordCount });
      }
    }
    return scenes;
  }
};

// src/analyzers/TextCleanup.ts
var TextCleanup = class {
  analyze(text) {
    const suggestions = [];
    this.checkRegex(text, /"|'/g, "quote", "Straight quotes used", suggestions);
    this.checkRegex(text, /--/g, "dash", "Double dash used (should be em-dash)", suggestions);
    this.checkRegex(text, /\.\.\./g, "ellipsis", "Three periods used (should be ellipsis char)", suggestions);
    this.checkRegex(text, /[ \t]+$/gm, "whitespace", "Trailing whitespace", suggestions);
    this.checkRegex(text, /  +/g, "whitespace", "Multiple spaces", suggestions);
    return {
      suggestions,
      stats: {
        quotes: suggestions.filter((s) => s.type === "quote").length,
        dashes: suggestions.filter((s) => s.type === "dash").length,
        ellipsis: suggestions.filter((s) => s.type === "ellipsis").length,
        whitespace: suggestions.filter((s) => s.type === "whitespace").length,
        controlChars: suggestions.filter((s) => s.type === "control-char").length,
        total: suggestions.length
      }
    };
  }
  clean(text) {
    let cleaned = text;
    cleaned = cleaned.replace(/(\s|^)"/g, "$1\u201C").replace(/"/g, "\u201D");
    cleaned = cleaned.replace(/(\s|^)'/g, "$1\u2018").replace(/'/g, "\u2019");
    cleaned = cleaned.replace(/ -- /g, " \u2014 ");
    cleaned = cleaned.replace(/--/g, "\u2014");
    cleaned = cleaned.replace(/\.\.\./g, "\u2026");
    cleaned = cleaned.replace(/[ \t]+$/gm, "");
    cleaned = cleaned.replace(/  +/g, " ");
    return cleaned;
  }
  checkRegex(text, regex, type, desc, suggestions) {
    let match;
    const re = new RegExp(regex);
    while ((match = re.exec(text)) !== null) {
      suggestions.push({
        id: `cleanup-${suggestions.length}`,
        type,
        original: match[0],
        replacement: "",
        // Would need specific logic to know *what* to replace with exactly in specific contexts
        position: { start: match.index, end: match.index + match[0].length },
        description: desc
      });
      if (!re.global)
        break;
    }
  }
  applySuggestions(text, suggestions) {
    const sorted = [...suggestions].sort((a, b) => b.position.start - a.position.start);
    let result = text;
    for (const suggestion of sorted) {
      const before = result.slice(0, suggestion.position.start);
      const after = result.slice(suggestion.position.end);
      result = before + suggestion.replacement + after;
    }
    return result;
  }
};

// src/services/AnalysisService.ts
var AnalysisService = class {
  constructor(settings) {
    this.settings = settings;
    this.statsAnalyzer = new StatisticsAnalyzer();
    this.readabilityAnalyzer = new ReadabilityAnalyzer();
    this.styleAnalyzer = new StyleAnalyzer();
    this.fictionAnalyzer = new FictionAnalyzer();
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  analyze(text) {
    const stats = this.statsAnalyzer.analyze(text);
    const readability = this.readabilityAnalyzer.analyze(text, stats.words, stats.sentences);
    const style = this.styleAnalyzer.analyze(text);
    const fiction = this.fictionAnalyzer.analyze(text);
    return {
      stats,
      readability,
      style,
      fiction,
      analyzedAt: new Date(),
      documentHash: this.simpleHash(text)
    };
  }
  simpleHash(text) {
    let hash = 0, i, chr;
    if (text.length === 0)
      return hash.toString();
    for (i = 0; i < text.length; i++) {
      chr = text.charCodeAt(i);
      hash = (hash << 5) - hash + chr;
      hash |= 0;
    }
    return hash.toString();
  }
};

// src/services/CleanupService.ts
var CleanupService = class {
  constructor(settings) {
    this.settings = settings;
    this.textCleanup = new TextCleanup();
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  analyze(text) {
    return this.textCleanup.analyze(text);
  }
  clean(text) {
    const cleaned = text;
    return this.textCleanup.clean(text);
  }
  applySuggestion(text, suggestion) {
    return this.textCleanup.applySuggestions(text, [suggestion]);
  }
};

// src/services/PersonaService.ts
var PersonaService = class {
  constructor(settings, gateway) {
    this.personas = {
      "booktuber": 'You are a lively, energetic BookTuber who reviews fiction. You focus on hooks, pacing, and "vibes". You use emoji and slang. You care if the book is "bingeable".',
      "hardcore": 'You are a hardcore sci-fi/fantasy reader. You obsess over worldbuilding consistency, magic systems, and logical plot progression. You hate plotholes and "hand-waving".',
      "casual": "You are a casual reader who reads for fun on the commute. You want simple, clear prose and engaging characters. You dislike confusion or purple prose."
    };
    this.settings = settings;
    this.gateway = gateway;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async evaluate(text, personaId) {
    const systemPrompt = this.personas[personaId];
    if (!systemPrompt) {
      throw new Error(`Persona ${personaId} not found`);
    }
    const prompt = `
Read the following text excerpt and evaluate it based on your persona.
Provide a JSON response with the following structure:
{
    "rating": (1-5 number),
    "summary": "One sentence summary of your impression",
    "strengths": ["point 1", "point 2"],
    "weaknesses": ["point 1", "point 2"],
    "fullEvaluation": "A paragraph explaining your thoughts in your persona's voice"
}

Text to evaluate:
---
${text}
---
`;
    try {
      const resultRaw = await this.gateway.complete(prompt, {
        systemPrompt
      });
      const jsonStr = resultRaw.replace(/```json/g, "").replace(/```/g, "").trim();
      const result = JSON.parse(jsonStr);
      return {
        personaId,
        personaName: personaId.charAt(0).toUpperCase() + personaId.slice(1),
        rating: result.rating,
        summary: result.summary,
        strengths: result.strengths,
        weaknesses: result.weaknesses,
        fullEvaluation: result.fullEvaluation,
        evaluatedAt: new Date()
      };
    } catch (error) {
      console.error("Persona evaluation failed", error);
      throw error;
    }
  }
};

// src/gateway/LLMGateway.ts
var import_obsidian3 = require("obsidian");
var LLMGateway = class {
  constructor(settings) {
    this.settings = settings;
  }
  updateSettings(settings) {
    this.settings = settings;
  }
  async checkConnection() {
    if (this.settings.llm.preferLocal) {
      try {
        const response = await (0, import_obsidian3.requestUrl)({
          url: `${this.settings.llm.ollamaBaseUrl}/api/tags`,
          method: "GET",
          throw: false
        });
        if (response.status === 200) {
          return {
            provider: "ollama",
            isConnected: true,
            isLocal: true,
            modelName: this.settings.llm.ollamaModel,
            lastChecked: new Date()
          };
        }
      } catch (e) {
      }
    }
    const provider = this.settings.llm.defaultCloudProvider;
    const hasKey = this.getApiKey(provider);
    if (hasKey) {
      return {
        provider,
        isConnected: true,
        isLocal: false,
        modelName: provider,
        lastChecked: new Date()
      };
    }
    return {
      provider: null,
      isConnected: false,
      isLocal: false,
      modelName: null,
      lastChecked: new Date(),
      error: "No valid provider found"
    };
  }
  async complete(prompt, options) {
    const status = await this.checkConnection();
    if (!status.isConnected || !status.provider) {
      throw new Error("No LLM provider connected");
    }
    if (status.provider === "ollama") {
      return this.completeOllama(prompt, options);
    } else if (status.provider === "gemini") {
      return this.completeGemini(prompt, options);
    }
    throw new Error(`Provider ${status.provider} not yet implemented`);
  }
  async completeOllama(prompt, options) {
    const body = {
      model: this.settings.llm.ollamaModel,
      prompt,
      stream: false,
      options: {
        temperature: (options == null ? void 0 : options.temperature) || 0.7,
        num_predict: (options == null ? void 0 : options.maxTokens) || 2048
      },
      system: options == null ? void 0 : options.systemPrompt
    };
    try {
      const response = await (0, import_obsidian3.requestUrl)({
        url: `${this.settings.llm.ollamaBaseUrl}/api/generate`,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      if (response.status === 200) {
        return JSON.parse(response.json).response;
      } else {
        throw new Error(`Ollama error: ${response.status}`);
      }
    } catch (error) {
      throw new Error(`Ollama connection failed: ${error}`);
    }
  }
  async completeGemini(prompt, options) {
    const model = "gemini-pro";
    const url = `https://generativelanguage.googleapis.com/v1beta/models/${model}:generateContent?key=${this.settings.llm.geminiApiKey}`;
    const body = {
      contents: [{
        parts: [{ text: ((options == null ? void 0 : options.systemPrompt) ? options.systemPrompt + "\\n\\n" : "") + prompt }]
      }],
      generationConfig: {
        temperature: (options == null ? void 0 : options.temperature) || 0.7,
        maxOutputTokens: (options == null ? void 0 : options.maxTokens) || 2048
      }
    };
    try {
      const response = await (0, import_obsidian3.requestUrl)({
        url,
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(body)
      });
      if (response.status === 200) {
        const data = response.json;
        return data.candidates[0].content.parts[0].text;
      } else {
        throw new Error(`Gemini error: ${response.status}`);
      }
    } catch (error) {
      throw new Error(`Gemini request failed: ${error}`);
    }
  }
  getApiKey(provider) {
    switch (provider) {
      case "gemini":
        return this.settings.llm.geminiApiKey;
      case "openai":
        return this.settings.llm.openaiApiKey;
      case "anthropic":
        return this.settings.llm.anthropicApiKey;
      default:
        return "";
    }
  }
};

// main.ts
var SmartWritingCompanion = class extends import_obsidian4.Plugin {
  async onload() {
    await this.loadSettings();
    this.analysisService = new AnalysisService(this.settings);
    this.cleanupService = new CleanupService(this.settings);
    this.llmGateway = new LLMGateway(this.settings);
    this.personaService = new PersonaService(this.settings, this.llmGateway);
    this.registerView(
      VIEW_TYPE_COMPANION,
      (leaf) => new CompanionView(leaf, this)
    );
    this.addRibbonIcon("book-open", "SmartWriting Companion", () => {
      this.activateView();
    });
    this.addCommand({
      id: "open-smart-writing-companion",
      name: "Open SmartWriting Companion",
      callback: () => {
        this.activateView();
      }
    });
    this.addSettingTab(new SWCSettingTab(this.app, this));
    this.registerEvent(this.app.workspace.on("file-open", (file) => {
      const leaf = this.app.workspace.getLeaf(false);
      if (leaf)
        this.addIconToHeader(leaf);
    }));
    this.registerEvent(this.app.workspace.on("active-leaf-change", (leaf) => {
      if (leaf)
        this.addIconToHeader(leaf);
    }));
    this.app.workspace.onLayoutReady(() => {
      this.app.workspace.iterateAllLeaves((leaf) => {
        this.addIconToHeader(leaf);
      });
    });
  }
  async onunload() {
  }
  addIconToHeader(leaf) {
    if (!leaf.view)
      return;
    if (leaf.view.getViewType() === "markdown") {
      const view = leaf.view;
      const existing = view.containerEl.querySelector(".swc-header-action");
      if (existing)
        return;
      const action = view.addAction("book-open", "Open SmartWriting Companion", () => {
        this.activateView();
      });
      action.classList.add("swc-header-action");
    }
  }
  async loadSettings() {
    this.settings = Object.assign({}, DEFAULT_SETTINGS, await this.loadData());
  }
  async saveSettings() {
    await this.saveData(this.settings);
  }
  async activateView() {
    const { workspace } = this.app;
    let leaf = null;
    const leaves = workspace.getLeavesOfType(VIEW_TYPE_COMPANION);
    if (leaves.length > 0) {
      leaf = leaves[0];
    } else {
      const rightLeaf = workspace.getRightLeaf(false);
      if (rightLeaf) {
        leaf = rightLeaf;
        await leaf.setViewState({ type: VIEW_TYPE_COMPANION, active: true });
      }
    }
    if (leaf) {
      workspace.revealLeaf(leaf);
    }
  }
};
